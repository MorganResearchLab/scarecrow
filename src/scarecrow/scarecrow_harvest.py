#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
@author: David Wragg
"""

from argparse import RawTextHelpFormatter
from scarecrow.fastq_logging import log_errors, setup_logger, logger
import numpy as np
import pandas as pd
from scipy.signal import find_peaks

def parser_harvest(parser):
    subparser = parser.add_parser(
        "harvest",
        description="""
Harvest barcode start-end positions from barcode alignment distributions.

Example:
---
""",
        help="Harvest barcode start-end positions",
        formatter_class=RawTextHelpFormatter,
    )
    subparser.add_argument("barcodes", nargs="+", help="List of barcode CSV files")
    subparser.add_argument(
        "-o", "--out",
        metavar="barcodes.positions",
        help=("Path to output barcode positions file"),
        type=str,
        default="./barcodes.positions",
    )
    subparser.add_argument(
        "-b", "--barcode_count",
        metavar="barcode_count",
        help=("Number of barcodes expected [3]"),
        type=int,
        default=3,
    )    
    subparser.add_argument(
        "-l", "--logfile",
        metavar="logfile",
        help=("File to write log to"),
        type=str,
        default="./scarecrow.log",
    )
    return subparser

def validate_harvest_args(parser, args):
    run_harvest(barcodes = args.barcodes, output_file = args.out, num_barcodes = args.barcode_count,
                logfile = args.logfile)

def run_harvest(barcodes, output_file, num_barcodes, logfile):
    """
    Extract barcode positions from distribution of barcode alignments 
    Expects as an input a series of CSV files generated by scarecrow barcodes
    """
    
    # Global logger setup
    logger = setup_logger(logfile)

    # Open file for writing output
    if output_file:
        f = open(f"{output_file}", 'w')

    # Read barcode CSV files into a dataframe using pandas
    #barcode_data = [pd.read_csv(file, sep="\t") for file in barcodes]
    results = get_barcode_peaks(barcodes, num_barcodes)

    print(f"{pd.DataFrame(results)}")

    
    print(f"{top_peak_positions(results, num_barcodes)}")

    return 

@log_errors
def get_barcode_peaks(barcodes: list, num_barcodes: int):
    """
    Read barcode CSV data in and identify peaks
    """
    barcode_data = pd.concat([pd.read_csv(file, sep='\t') for file in barcodes], ignore_index=True)

    # Identify barcode alignment peaks
    results = []
    barcode_groups = barcode_data.groupby(["read", "barcode_whitelist", "orientation"])
    for (read, barcode_whitelist, orientation), group in barcode_groups:
        # Use 'start' to find peaks
        peaks = find_top_peaks(group["start"].values, group["end"].values, num_barcodes)
        # Store the results
        results.append({
            "read": read,
            "barcode_whitelist": barcode_whitelist,
            "orientation": orientation,
            "peaks": peaks
        })
        # Log the results
        logger.info(f"read: {read} {barcode_whitelist} {orientation} - peaks: {peaks}")

    # Sort the results by the highest peak count
    sorted_results = sorted(
        results,
        key=lambda x: max([count for _, _, count in x["peaks"]] or [0]),  # Extract the highest count from (start, count, end)
        reverse=True
    )

    return sorted_results

def find_top_peaks(start_positions, end_positions, num_peaks):
    """
    Find top peaks based on start positions, while also returning the corresponding end positions.
    """
    # Count frequency of each start position
    position_counts = pd.Series(start_positions).value_counts().sort_index()
    
    # Identify peaks in the frequency data
    peaks, _ = find_peaks(position_counts.values)
    
    # Extract peak positions and their counts, including end positions
    peaks_with_counts = []
    for p in peaks:
        start_pos = position_counts.index[p]
        end_pos = end_positions[start_positions == start_pos][0]  # Get the corresponding end position
        count = position_counts.values[p]
        peaks_with_counts.append((start_pos, end_pos, count))
    
    # Sort peaks by count and select the top N
    top_peaks = sorted(peaks_with_counts, key=lambda x: x[2], reverse=True)[:num_peaks]
    return top_peaks


def top_peak_positions(results, num_barcodes):
    # Flatten the results to include individual peaks
    flattened_results = []
    for result in results:
        for start_position, end_position, count in result["peaks"]:
            flattened_results.append({
                "start_position": start_position,
                "end_position": end_position,
                "count": count,
                "barcode_whitelist": result["barcode_whitelist"],
                "read": result["read"],
                "orientation": result["orientation"],
            })

    # Convert to a DataFrame
    flattened_df = pd.DataFrame(flattened_results)

    # Group by position and barcode_whitelist, then sum counts (if necessary)
    grouped = flattened_df.groupby(["start_position", "barcode_whitelist"], as_index=False).sum()

    # Sort by count (descending) and position (ascending)
    sorted_grouped = grouped.sort_values(by=["count", "start_position"], ascending=[False, True])

    # Select the top 3 distinct positions
    top_positions = []
    seen_positions = set()

    for _, row in sorted_grouped.iterrows():
        if row["start_position"] not in seen_positions:
            top_positions.append(row)
            seen_positions.add(row["start_position"])
            if len(top_positions) == num_barcodes:
                break

    # Create a DataFrame of the results
    top_positions_df = pd.DataFrame(top_positions).sort_values(by="start_position", ascending=True)

    return top_positions_df
