<img style="float:right;width:100px;" src="../img/scarecrow.png" alt="scarecrow"/>

[Back to root](root.md)

# Example: Parse Evercode WTv2

<picture>
  <source media="(prefers-color-scheme: dark)" srcset="../img/WTv2_dark.svg">
  <img alt="Parse Evercode WTv2 library structure" src="../img/WTv2_light.svg">
</picture>

Stay organised - create a folder for the project to keep things tidy.

```bash
PROJECT=./scarecrow/examples/evercode
mkdir -p ${PROJECT}
```

Download Evercode WTv2 data from [https://www.ebi.ac.uk/ena/browser/view/PRJNA1106903](https://www.ebi.ac.uk/ena/browser/view/PRJNA1106903).

```bash
mkdir -p ${PROJECT}/fastq
wget -nc -P ${PROJECT}/fastq ftp.sra.ebi.ac.uk/vol1/fastq/SRR288/058/SRR28867558/SRR28867558_1.fastq.gz
wget -nc -P ${PROJECT}/fastq ftp.sra.ebi.ac.uk/vol1/fastq/SRR288/058/SRR28867558/SRR28867558_2.fastq.gz
```

### 1. Identify barcode seed positions

This step requires barcode whitelists associated with the assay being used. Parse Bioscience customers can access the whitelists for the different assays by downloading their splitpipe pipeline. The whitelists are csv files in a barcodes directory (e.g. barcode_data_v1.csv). We only require the barcode sequence for scarecrow, so this needs cutting from the file (i.e. `cut -d',' -f2 barcode_data_v1.csv | sed '1d' > barcode_data_v1.txt`). Once the whitelists are generated, they can be defined as colon-delimited strings (`<barcode index>:<whitelist name>:<whitelist file>`) in a bash array for later use.

```bash
BARCODES=(BC1:n99_v5:${PROJECT}/barcode_whitelists/bc_data_n99_v5.txt
          BC2:v1:${PROJECT}/barcode_whitelists/bc_data_v1.txt
          BC3:v1:${PROJECT}/barcode_whitelists/bc_data_v1.txt)
```

We can now run `scarecrow seed` to process each barcode whitelist. The below example is for a SLURM HPC, but will work on a standard PC by omitting the `sbatch` line. It randomly samples 10k reads from the first 1M in the FASTQ files and records the start positions of barcodes, their orientation, nucleotide frequencies per position, and conserved sequence runs.

```bash
mkdir -p ${PROJECT}/barcode_profiles
FASTQS=(${PROJECT}/fastq/*.fastq.gz)
for BARCODE in ${BARCODES[@]}
do
    sbatch --ntasks 1 --mem 1G --time=01:00:00 -o seed.%j.out -e seed.%j.err \
        scarecrow seed \
            --num_reads 10000 \
            --upper_read_count 1000000 \
            --fastqs ${FASTQS[@]} \
            --barcodes ${BARCODE} \
            --out ${PROJECT}/barcode_profiles/barcodes.${BARCODE%%:*}.csv
done
```

### 2. Harvest seed data

The barcode profiles generated by `scarecrow seed` are gathered with `scarecrow harvest` to identify the likely barcode positions. The `--barcode_count` parameter specifies the number of barcodes to return for **each** barcode index, and should typically be set to `1` unless debugging. The `--min_distance` parameter sets the minimum distance required between the end and start positions of two barcodes. The `--conserved` parameter enables the masking of conserved sequence regions - for instance barcode linker sequences, to prevent barcode positions falling within these regions.

```bash
BARCODE_FILES=(${PROJECT}/barcode_profiles/Parse/barcodes.*.csv)
sbatch --ntasks 1 --mem 2G --time=01:00:00 -o harvest.%j.out -e harvest.%j.err \
    scarecrow harvest \
        ${BARCODE_FILES[@]} \
        --barcode_count 1 \
        --min_distance 10 \
        --conserved ${PROJECT}/barcode_profiles/Parse/barcodes.${BARCODES[0]%%:*}_conserved.tsv \
        --out ${PROJECT}/barcode_profiles/Parse/barcode_positions.csv
```

### 3. Trim FASTQ sequences ###

To improve downstream alignment results it is highly recommended to trim the reads to remove and adapter sequences or template switching oligo (TSO) sequences. Not all reads possess these conserved sequences, and those that do will not necessarily share the same start position. Sometimes this information is available, for instance this assay has a TSO sequence of `AACGCAGAGTGAATGGG`. One option to identify if adapter sequences are present is to eyeball a few reads, for example to look at the first 10 sequences:

```bash
FASTQS=(${PROJECT}/fastq/*.fastq.gz)
gunzip -c ${FASTQS[0]} | grep -A1 --no-group-separator "^@" | grep -v "^@" | head
```

```bash
GNTGCAAAACAATATCCAAAAAGATTTTAAAAAAACAGTAAATTAAAACAAAGTTTTGCTTCTTTTCTCCACCA
TNGCAGTGGTATC'AACGCAGAGTGAATGGG'ATTACAGGCATGAGCCACTGCGCCTGGCCAAGATAGCAATTTTT
GNCTAATCGAACCATCTAGTAGCTGGTTCCCTCCGAAGTTTCCCTCAGGATAGCTGGCGCTCTCGCAGACCCGA
GNAAAAAAGAAATAATGAAAATCAAAGCAGAAATAAATGAATTTGAAATGAAGAAATTAATACAAAAGATCAAT
TNAAAAATGAAAGTGCCACAGTCTCAAGCACGTGGATGACGGATTAGTCTCAAGCACGTGGATGAGCCAATAGT
GNAAAGATCAACAAAATTGATAGACCGCTAGCAAGACTAATAAAGAAGAAAAGAGAGAAGAATCAAATAGACGC
TNGCAGTGGTATC'AACGCAGAGGTGAATGGG'GTGGGAAAAGATATTCCATGCAAATGGAAACCAAAAGCAAGCA
TNC'AACGCAGAGTGAATGGG'AAAAGAGCAATTCTACAATATAACCTTATATGCAAAAGCAACATAACTGTGTGT
'GNGTGAATGGG'GAACCTGGCTGGGAAAGCCTCCCTGAGAAGGGGAAGTGGGCAGGTTTGAGGGAGAGGAAGTCG
GNCAACTCCCCAACACATTAAACATGGAGTTACCATGTGACCTAGCAATTCCCTTCCTAAGAATCTCCCCAAGA
```

Sequences manually highlighted in red are relatively conserved and correspond with the known TSO sequence. To trim these sequences including any upstream bases, tailing `N`s, and short reads, we can use `cutadapt` as follows:

```bash
THREADS=4
FASTQS=(${PROJECT}/fastq/*.fastq.gz)
sbatch --ntasks ${THREADS} --mem 16G --time=12:00:00 -o cutadapt.%j.out -e cutadapt.%j.err \ 
    cutadapt --cores ${THREADS} --trim-n --minimum-length 30 -g AACGCAGAGTGAATGGG \
        -o ${FASTQS[0]%.fast*}_trimmed.fastq \
        -p ${FASTQS[1]%.fast*}_trimmed.fastq \
        ${FASTQS[@]}
```

### 4. Extract sequences and barcodes ###

Now that the barcode positions have been characterised we can extract the target sequence with `scarecrow reap`. This will also record barcode metadata (sequence, qualities, corrected sequence, positions, mismatches) and [*optionally*] UMI data (sequence, quailties). The output can be either SAM format (default) or FASTQ. The `--barcode_reverse_order` flag determines the order of barcode sequences in the tag. The range to `--extract` includes the read (`1` or `2`) followed by the positional range, and `--umi` follows the same format to indicate where the UMI sequence is. The `--jitter` parameter indicates the number of flanking bases to extend the barcode start position by when looking for a match. The `--mismatch` parameter indicates the maximum number of mismatches permitted when matching the barcode against a whitelist - also known as the edit distance. The `--base_quality` parameter base quality threshold below which bases are masked as `N`, this step occurs before barcode matching and can significantly reduce the number of valid barcodes if set too high. We recommend using the default `10` and applying additional quality filtering to the resulting fastq if required.

***does barcode_reverse_order update the other barcode metadata order?***

***UMI sequence position is more complicated in other libraries and may need to account for jitter***

```bash
mkdir -p ${PROJECT}/extracted
THREADS=16
BQ=10
JITTER=2
MISMATCH=2
FASTQS=(${PROJECT}/fastq/*.trimmed.fastq)
OUT=$(basename ${FASTQS[0]%.fastq*})
sbatch --ntasks ${THREADS} --mem 4G --time=12:00:00 -o reap.%j.out -e reap.%j.err \
    scarecrow reap \
        --threads ${THREADS} \
        --batch_size 20000 \
        --fastqs ${FASTQS[@]} \
        --barcode_positions ${PROJECT}/barcode_profiles/barcode_positions.csv \
        --barcode_reverse_order \
        --barcodes ${BARCODES[@]} \
        --extract 1:1-74 --umi 2:1-10 \
        --jitter ${JITTER} \
        --mismatch ${MISMATCH} \
        --base_quality ${BQ} \
        --out ${PROJECT}/extracted/${OUT} \
        --out_sam
```

In addition to generating the SAM file, `scarecrow reap` outputs a `_mismatch_stats.csv` and a `_position_stats.csv`. The mismatch_stats CSV has the following format:

```bash
mismatches,count
-3,5654876
-2,5249063
-1,16976272
0,126774904
1,11373736
2,1287519
3,156456
```

Indicating the number of reads recorded for each sum of mismatches across its barcodes. Negative numbers indicate the number of reads for which no barcode was found (i.e. -1 is one barcode unmatched, -2 is two barcodes unmatched, ...). Although we used `--mismatch 2`, a mismatch count of three is possible if for example each of the three barcodes has one mismatch, or one barcode has two mismatches and another has 1 mismatch.

The position_stats CSV follows a similar format, indicating the count of barcodes starting at each position within `--jitter 2` :

```bash
position,count
9,843639
10,2986137
11,162568743
12,792597
13,281710
47,1810251
48,8885605
49,154939989
50,1587644
51,249337
77,3125647
78,12576913
79,151770266
```

This illustrates that millions of reads have barcodes not starting at the expected positions.

### 5. Align with STAR

Given the compute requirements for running STAR this is best performed on a HPC. Alignment first requires the reference genome be indexed with STAR. Below is an example using 8 threads and used 48G on a SLURM HPC. The GRCh38 reference genome and annotation (GTF) were indexed using an overhang of 74 - the length of the read containing the sequence to align.

```bash
STAR --runThreadN ${SLURM_NTASKS} \
     --runMode genomeGenerate \
     --genomeDir ${GENOME_DIR} \
     --genomeFastaFiles ${GRCh38.FA} \
     --sjdbGTFfile ${GRCh38.GTF} \
     --sjdbOverhang 74
```

After indexing the reference genome, the SAM file generated by `scarecrow reap` is aligned using 32 threads and 48G on a SLURM HPC.

```bash
SAM=${PROJECT}/extracted/*.sam
ID=$(basename ${SAM})
mkdir -p ${PROJECT}/aligned

STAR --runThreadN ${SLURM_NTASKS} \
        --genomeDir ${GENOME_DIR} \
        --readFilesIn ${SAM} \
        --outFileNamePrefix ${PROJECT}/aligned/${ID%.sam}. \
        --outSAMtype BAM Unsorted \
        --outFilterMultimapNmax 3 
```

