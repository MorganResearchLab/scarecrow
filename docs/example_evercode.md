<img style="float:right;width:100px;" src="../img/scarecrow.png" alt="scarecrow"/>

[Back to root](root.md)

# Example: Parse Evercode WTv2

<picture>
  <source media="(prefers-color-scheme: dark)" srcset="../img/parse_dark_v2.svg">
  <img alt="Parse Evercode WTv2 library structure" src="../img/parse_light_v2.svg">
</picture>

Library structure

---

### Prep

Stay organised - create a folder for the project to keep things tidy.

```bash
PROJECT=./scarecrow/examples/Parse
mkdir -p ${PROJECT}
```

Download Evercode WTv2 data from NCBI SRA accession:[SRR28867558](https://www.ncbi.nlm.nih.gov/sra/?term=SRR28867558).

```bash
mkdir -p ${PROJECT}/fastq
ACC=SRR28867558
#sbatch ./scarecrow/scripts/fastq-dump.sh --out ${PROJECT}/fastq --acc ${ACC}
prefetch --output-directory ${PROJECT}/fastq ${ACC}
fasterq-dump ${PROJECT}/fastq/${ACC} -e 2 --split-files --include-technical --force --outdir ${PROJECT}/fastq
gzip ${PROJECT}/fastq/${ACC}_1.fastq # Index
gzip ${PROJECT}/fastq/${ACC}_2.fastq # cDNA sequences
gzip ${PROJECT}/fastq/${ACC}_3.fastq # Barcodes and UMI
```


### 1. Identify barcode seeds

This step requires barcode whitelists associated with the assay being used. Parse Bioscience customers can access the whitelists for the different assays by downloading their splitpipe pipeline. The whitelists are csv files in a barcodes directory (e.g. barcode_data_v1.csv). We only require the barcode sequence for scarecrow, so this needs cutting from the file (i.e. `cut -d',' -f2 barcode_data_v1.csv | sed '1d' > barcode_data_v1.txt`). Once the whitelists are generated, they can be defined as colon-delimited strings (`<barcode index>:<whitelist name>:<whitelist file>`) in a bash array for later use.

```bash
BARCODES=(BC1:n99_v5:${PROJECT}/barcode_whitelists/bc_data_n99_v5.txt
          BC2:v1:${PROJECT}/barcode_whitelists/bc_data_v1.txt
          BC3:v1:${PROJECT}/barcode_whitelists/bc_data_v1.txt)
```

We can now run `scarecrow seed` to process each barcode whitelist. The below example is for a SLURM HPC, but will work on a standard PC by omitting the `sbatch` line. It randomly samples 10k reads from the first 100k in the FASTQ files and records the start positions of barcodes, their orientation, nucleotide frequencies per position, and conserved sequence runs.

```bash
mkdir -p ${PROJECT}/barcode_profiles
FASTQS=(${PROJECT}/fastq/*.fastq.gz)
for BARCODE in ${BARCODES[@]}
do
    scarecrow seed \
        --num_reads 10000 \
        --upper_read_count 100000 \
        --fastqs ${FASTQS[@]} \
        --barcodes ${BARCODE} \
        --out ${PROJECT}/barcode_profiles/barcodes.${BARCODE%%:*}.csv
done
```

### 2. Harvest barcode profiles

The barcode profiles generated by `scarecrow seed` are gathered with `scarecrow harvest` to identify the likely barcode index positions. The `--barcode_count` parameter specifies the number of barcodes to return for **each** barcode index, and should typically be set to `1` unless debugging. The `--min_distance` parameter sets the minimum distance required between the end and start positions of two barcodes. The `--conserved` parameter enables the masking of conserved sequence regions - for instance barcode linker sequences, to prevent barcode positions falling within these regions.

```bash
BARCODE_FILES=(${PROJECT}/barcode_profiles/barcodes.*.csv)
scarecrow harvest \
    ${BARCODE_FILES[@]} \
    --barcode_count 1 \
    --min_distance 10 \
    --conserved ${PROJECT}/barcode_profiles/barcodes.${BARCODES[0]%%:*}_conserved.tsv \
    --out ${PROJECT}/barcode_profiles/barcode_positions.csv
```

The plot generated by `harvest` indicates that no barcode matches were found on read 1 (SRR28867558_1.fastq.gz), virtually no barcode matches were found on read 2 (SRR28867558_2.fastq.gz), regardless of barcode orientation, while matches were found on read 3 (SRR28867558_3.fastq.gz) in both orientations. The majority of reads returned matches at positions 11, 49, and 79 in forward orientation, which correspond with the positions of the 3 barcodes expected of the assay. An additional peak was identified in a conserved region (highlighted in red) that corresponds with one of the linker sequences of the assay. As this peak falls within a conserved region it is ignored.

<br>
<table>
  <tr>
    <td><img src="../img/parse_index_1_forward.png" alt="Barcode profiles for FASTQ index 1, forward orientation"></td>
    <td><img src="../img/parse_index_1_reverse.png" alt="Barcode profiles for FASTQ index 1, reverse orientation"></td>
  </tr>
  <tr>
    <td><img src="../img/parse_index_2_forward.png" alt="Barcode profiles for FASTQ index 2, forward orientation"></td>
    <td><img src="../img/parse_index_2_reverse.png" alt="Barcode profiles for FASTQ index 2, reverse orientation"></td>
  </tr>
</table>
<br>

The regions for the three barcodes (one per whitelist) selected by the `harvest` are highlighted in blue. These are recorded in the barcode_positions.csv file. Note, file_index is 0-based.

```bash
barcode_whitelist,file_index,file,orientation,start,end,read_count,read_fraction
BC2:v1,2,SRR28867558_3.fastq.gz,forward,11,18,8850,0.93
BC3:v1,2,SRR28867558_3.fastq.gz,forward,49,56,8327,0.87
BC1:n99_v5,2,SRR28867558_3.fastq.gz,forward,79,86,7447,0.8
```


### 2. Reap sequence data ###

Now that the barcode positions have been characterised we can extract the target sequence with `scarecrow reap`. This will also record barcode metadata (sequence, qualities, corrected sequence, positions, mismatches) and [*optionally*] UMI data (sequence, quailties). The output can be either SAM format (default) or FASTQ. The range to `--extract` includes the read (`1` or `2`) followed by the positional range, and `--umi` follows the same format to indicate where the UMI sequence is. The `--jitter` parameter indicates the number of flanking bases to extend the barcode start position by when looking for a match. The `--mismatch` parameter indicates the maximum number of mismatches permitted when matching the barcode against a whitelist - also known as the edit distance. The `--base_quality` parameter base quality threshold below which bases are masked as `N`, this step occurs before barcode matching and can significantly reduce the number of valid barcodes if set too high. We recommend using the default `10` and applying additional quality filtering to the resulting output as required. Finally, `--sift` indicates that we do not wish to retain any reads for which any barcode failed to return a match after accounting for jitter and mismatches. These 'invalid' barcodes include those that are ambiguous - in other words barcodes who return multiple equidistant matches with the same number of mismatches.

Note, we're running this on a SLURM HPC and it takes around 58 mins using 16 cores.

```bash
mkdir -p ${PROJECT}/extracted
THREADS=16
BQ=10
JITTER=2
MISMATCH=2
FASTQS=(${PROJECT}/fastq/*.fastq.gz)
OUT=$(basename ${FASTQS[0]%.fastq*})
sbatch --ntasks 1 --cpus-per-task ${THREADS} --mem 16G --time=12:00:00 -o reap.%j.out -e reap.%j.err \
    scarecrow reap \
        --threads ${THREADS} \
        --batch_size 20000 \
        --fastqs ${FASTQS[@]} \
        --barcode_positions ${PROJECT}/barcode_profiles/barcode_positions.csv \
        --barcodes ${BARCODES[@]} \
        --extract 2:1-74 --umi 3:1-10 \
        --jitter ${JITTER} \
        --mismatch ${MISMATCH} \
        --base_quality ${BQ} \
        --out ${PROJECT}/extracted/${OUT} \
        --out_fastq --sift
```

In addition to generating an interleaved FASTQ file, it outputs a JSON file indicating the barcode and UMI positions on read 1, and the parameters required to use the file with the `kb count` tool of `kallisto-bustools`. In addition, the tools outputs a `_mismatch_stats.csv` and a `_position_stats.csv` file. The mismatch_stats CSV has the following format:

```bash
mismatches,count
-3,3434872
-2,2328623
-1,13064342
0,126768927
1,12071412
2,6884512
3,1214758
4,991680
5,422505
6,293141
```

Indicating the number of reads recorded for each sum of mismatches across its barcodes. For example, allowing up to 2 mismatches for 3 barcodes will sum to 6 if each barcode has 2 mismatches. Negative numbers indicate the number of reads for which no barcode was found (i.e. -1 is one barcode unmatched, -2 is two barcodes unmatched, ...).

The position_stats CSV follows a similar format, indicating the count of barcodes starting at each position within `--jitter 2` :

```bash
position,count
10,3599189
11,154669696
12,1449340
13,525384
47,2067460
48,9485814
49,146188365
50,2350402
51,667344
77,3619040
78,13545713
79,133008992
80,2252858
81,144060
9,824455
N,28026204
```

This illustrates that millions of reads have barcodes not starting at the expected positions.


### 3. Trim TSO sequences ### I have not run this section as trimming is best before after reap and before aligning

To improve downstream alignment results it is highly recommended to trim the reads to remove and adapter sequences or template switching oligo (TSO) sequences. Not all reads possess these sequences, and those that do will not necessarily share the same start position. There is a contaminants list in the Parse splitpipe repo which can be formatted for use with cutadapt and supplemented with the Parse TSO sequence `AACGCAGAGTGAATGGG`.

```bash
CONTAMINANTS=./software/ParseBiosciences-Pipeline.1.4.1/splitpipe/scripts/config/fastqc-contaminant_list.txt
awk '
# Skip blank lines and comment lines
NF && $0 !~ /^#/ {
  seq = $NF
  header = ""
  for (i = 1; i < NF; i++) {
    header = header $i " "
  }
  gsub(/[ \t]+$/, "", header)
  # Use a separate array to track seen sequences
  if (header != "" && !(seq in seen)) {
    seen[seq] = 1
    print ">" header
    print seq
  }
}
' ${CONTAMINANTS} > ./${PROJECT}/contaminants.fasta

# Add Parse Bio TSO sequence to contaminants
sed -i '$ a >Parse Bio TSO sequence\nAACGCAGAGTGAATGGG' ./${PROJECT}/contaminants.fasta

FASTQS=(${PROJECT}/fastq/*.fastq.gz)
OUT=$(basename ${FASTQS[0]%.fastq*})

sbatch --ntasks 1 --cpus-per-task 4 --mem 16G --time=12:00:00 -o cutadapt.%j.out -e cutadapt.%j.err \
    cutadapt --cores 4 --trim-n --minimum-length 30 --interleaved \
        -g file:./${PROJECT}/contaminants.fasta \
        -o ${PROJECT}/extracted/${OUT}_trimmed.fastq \
        ${PROJECT}/extracted/${OUT}.fastq
```
2510323
==> cutadapt.2510323.err <==
Error in FASTQ file at line 172: Length of sequence and qualities differ












### 5. Align with STAR

Given the compute requirements for running STAR this is best performed on a HPC. Alignment first requires the reference genome be indexed with STAR. Below is an example using 8 threads and used 48G on a SLURM HPC. The GRCh38 reference genome and annotation (GTF) were indexed using an overhang of 74 - the length of the read containing the sequence to align.

```bash
STAR --runThreadN ${SLURM_NTASKS} \
     --runMode genomeGenerate \
     --genomeDir ${GENOME_DIR} \
     --genomeFastaFiles ${GRCh38.FA} \
     --sjdbGTFfile ${GRCh38.GTF} \
     --sjdbOverhang 74
```

After indexing the reference genome, the SAM file generated by `scarecrow reap` is aligned using 32 threads and 48G on a SLURM HPC.

```bash
SAM=${PROJECT}/extracted/*.sam
ID=$(basename ${SAM})
mkdir -p ${PROJECT}/aligned

STAR --runThreadN ${SLURM_NTASKS} \
        --genomeDir ${GENOME_DIR} \
        --readFilesIn ${SAM} \
        --outFileNamePrefix ${PROJECT}/aligned/${ID%.sam}. \
        --outSAMtype BAM Unsorted \
        --outFilterMultimapNmax 3
```
